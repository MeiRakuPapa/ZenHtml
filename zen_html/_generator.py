"""
_generator.py

This module provides functionality for generating Python classes and methods that represent HTML tags.
It uses the tag specifications defined in `_tag_spec.py` to dynamically create helper methods for each tag.

Functions:
    generate_class: Generates the `H` class with methods for each HTML tag.
    generate_signature: Creates the function signature for an HTML tag helper.
"""

# Copyright (c) 2025 Yusuke KITAGAWA (tonosama_kaeru@icloud.com)

from textwrap import indent

from ._base import R_PROP_NAME_MAP, VOID_TAGS
from ._tag_spec import TAG_SPEC, PropOptions, TagConfig, normalized_tag_spec


def _literal(values: list[str]) -> str:
    joined = ", ".join(f'"{v}"' for v in values)
    return f"Literal[{joined}]"


def _python_prop_name(html_name: str) -> str:
    mapped = R_PROP_NAME_MAP.get(html_name)
    if mapped:
        return mapped
    candidate = html_name.replace("-", "_").replace(":", "__")
    if not candidate.isidentifier():
        raise ValueError(f"Invalid attribute name: {html_name}")
    return candidate


def _annotation(props: PropOptions) -> tuple[str, bool]:
    required = props.get("required", False)
    kind = props.get("kind", "str")

    if kind == "choices":
        values = props.get("values", [])
        if not values:
            raise ValueError("choices kind requires 'values'")
        annot = _literal(values)
    elif kind == "bool":
        annot = "bool"
    else:
        annot = "str"

    if not required:
        annot = f"{annot} | None"
    return annot, required


def generate_signature(tag: str, spec: list[tuple[str, PropOptions]]) -> str:
    """
    Generates the function signature for an HTML tag helper method.

    Args:
        tag (str): The name of the HTML tag.
        spec (list[tuple[str, PropOptions]]): The list of attributes and their options for the tag.

    Returns:
        str: The function signature as a string.
    """
    is_void = tag in VOID_TAGS

    params: list[str] = []
    if not is_void:
        params.append("*_children: Children")
        params.append("children: Children | None = None")
    elif spec:
        params.append("*")

    for html_name, options in spec:
        python_name = _python_prop_name(html_name)
        annotation, required = _annotation(options)
        if html_name == "class":
            annotation = "ClassAttr"
            required = False
        if tag == "del" and python_name == "del":
            python_name = "del_"
        if required:
            params.append(f"{python_name}: {annotation}")
        else:
            params.append(f"{python_name}: {annotation} = None")

    params.append("**props: PropVal")

    param_indent = " " * 4
    args = f"{param_indent}" + f",\n{param_indent}".join(params)
    fname = tag if tag != "del" else "del_"
    return f'def {fname}(\n{args},\n) -> "H": ...'


def generate_class(*, spec: dict[str, TagConfig] = TAG_SPEC, output: str | None = None) -> None:
    """
    Generates the `H` class with methods for each HTML tag based on the tag specification.

    Args:
        spec (dict[str, TagConfig], optional): The tag specification. Defaults to TAG_SPEC.
        output (str | None, optional): The output file path. If None, prints to stdout.

    Returns:
        None
    """

    out = []
    out.append("# This file is auto-generated by zen_html._generator.")
    out.append("# Do not edit this file directly; update _tag_spec.py and rerun the generator.")
    out.append("# mypy: disable-error-code=empty-body")
    out.append("# mypy: disable-error-code=misc")

    out.append("from typing import Literal")
    out.append("from ._base import Children, ClassAttr, PropVal, _HBase, html_tag")
    out.append("")
    out.append("class H(_HBase):")

    normalized = normalized_tag_spec(spec)

    for tagname, props in normalized.items():
        if tagname in [
            "html",
            "article",
            "p",
            "em",
            "ins",
            "picture",
            "table",
            "form",
            "details",
            "script",
            "link",
        ]:
            out.append("")

        sig = generate_signature(tagname, props)
        block = f"@html_tag\n{sig}"
        out.append(indent(block, "    "))
        out.append("")

    code = "\n".join(out)

    if output is None:
        print(code)
    else:
        with open(output, "w", encoding="utf-8") as f:
            f.write(code)
